package zerogod

import (
	"net"
	"strings"
	"time"

	"github.com/bettercap/bettercap/v2/modules/zerogod/zeroconf"
	"github.com/bettercap/bettercap/v2/network"
	"github.com/bettercap/bettercap/v2/session"
	"github.com/evilsocket/islazy/tui"
	"github.com/google/gopacket"
	"github.com/google/gopacket/layers"
)

// a service has been discovered
type ServiceDiscoveryEvent struct {
	Service  zeroconf.ServiceEntry `json:"service"`
	Endpoint *network.Endpoint     `json:"endpoint"`
}

// an endpoint is browsing for specific services
type BrowsingEvent struct {
	Source   string            `json:"source"`
	Query    layers.DNS        `json:"service"`
	Endpoint *network.Endpoint `json:"endpoint"`
}

func (mod *ZeroGod) onServiceDiscovered(svc *zeroconf.ServiceEntry) {
	mod.Debug("%++v", *svc)

	if svc.Service == DNSSD_DISCOVERY_SERVICE && len(svc.AddrIPv4) == 0 && len(svc.AddrIPv6) == 0 {
		svcName := strings.Replace(svc.Instance, ".local", "", 1)
		if !mod.browser.HasResolverFor(svcName) {
			mod.Debug("discovered service %s", tui.Green(svcName))
			if ch, err := mod.browser.StartBrowsing(svcName, "local.", mod); err != nil {
				mod.Error("%v", err)
			} else {
				// start listening on this channel
				go func() {
					for entry := range ch {
						mod.onServiceDiscovered(entry)
					}
				}()
			}
		}
		return
	}

	mod.Debug("discovered instance %s (%s) [%v / %v]:%d",
		tui.Green(svc.ServiceInstanceName()),
		tui.Dim(svc.HostName),
		svc.AddrIPv4,
		svc.AddrIPv6,
		svc.Port)

	event := ServiceDiscoveryEvent{
		Service:  *svc,
		Endpoint: nil,
	}

	addresses := append(svc.AddrIPv4, svc.AddrIPv6...)

	for _, ip := range addresses {
		address := ip.String()
		if event.Endpoint = mod.Session.Lan.GetByIp(address); event.Endpoint != nil {
			// update internal mapping
			mod.browser.AddServiceFor(address, svc)
			// update endpoint metadata
			mod.updateEndpointMeta(address, event.Endpoint, svc)
			break
		}
	}

	if event.Endpoint == nil {
		// TODO: this is probably an IPv6 only record, try to somehow check which known IPv4 it is
		mod.Debug("got mdns entry for unknown ip: %++v", *svc)
	}

	session.I.Events.Add("zeroconf.service", event)
	session.I.Refresh()
}

func (mod *ZeroGod) onPacket(pkt gopacket.Packet) {
	mod.Debug("%++v", pkt)

	netLayer := pkt.NetworkLayer()
	if netLayer == nil {
		mod.Warning("not network layer in packet %+v", pkt)
		return
	}
	var srcIP net.IP
	// var dstIP net.IP
	switch netLayer.LayerType() {
	case layers.LayerTypeIPv4:
		ip := netLayer.(*layers.IPv4)
		srcIP = ip.SrcIP
		// dstIP = ip.DstIP
	case layers.LayerTypeIPv6:
		ip := netLayer.(*layers.IPv6)
		srcIP = ip.SrcIP
		// dstIP = ip.DstIP
	default:
		mod.Warning("unexpected network layer type %v in packet %+v", netLayer.LayerType(), pkt)
		return
	}

	// not interested in packet generated by us
	if srcIP.Equal(mod.Session.Interface.IP) || srcIP.Equal(mod.Session.Interface.IPv6) {
		mod.Debug("skipping local packet")
		return
	}

	udp := pkt.Layer(layers.LayerTypeUDP)
	if udp == nil {
		mod.Warning("not udp layer in packet %+v", pkt)
		return
	}

	dns := layers.DNS{}
	if err := dns.DecodeFromBytes(udp.LayerPayload(), gopacket.NilDecodeFeedback); err != nil {
		mod.Warning("could not decode DNS (%v) in packet %+v", err, pkt)
		return
	}

	// since the browser is already checking for these, we are only interested in queries
	numQs := len(dns.Questions)
	if numQs == 0 {
		mod.Debug("skipping answers only packet")
		return
	}

	event := BrowsingEvent{
		Source:   srcIP.String(),
		Query:    dns,
		Endpoint: mod.Session.Lan.GetByIp(srcIP.String()),
	}

	if event.Endpoint == nil {
		// TODO: if nil, this is probably an IPv6 only record, try to somehow check which known IPv4 it is
		// TODO: make configurable?
		mod.Debug("got mdns packet from unknown ip %s: %++v", srcIP, dns)
		return
	}

	session.I.Events.Add("zeroconf.browsing", event)
	session.I.Refresh()
}

func (mod *ZeroGod) startDiscovery(service string) (err error) {
	mod.Debug("starting resolver for service %s", tui.Yellow(service))

	// create passive sniffer
	if mod.sniffer != nil {
		mod.sniffer.Close()
	}

	readTimeout := 500 * time.Millisecond
	if mod.sniffer, err = network.CaptureWithTimeout(mod.Session.Interface.Name(), readTimeout); err != nil {
		return err
	} else if err = mod.sniffer.SetBPFFilter("udp and port 5353"); err != nil {
		return err
	}
	// prepare source and start listening for packets
	src := gopacket.NewPacketSource(mod.sniffer, mod.sniffer.LinkType())
	mod.snifferCh = src.Packets()
	// start listening for new packets
	go func() {
		mod.Debug("sniffer started")
		for pkt := range mod.snifferCh {
			if !mod.Running() {
				mod.Debug("end pkt loop (pkt=%v)", pkt)
				break
			}
			mod.onPacket(pkt)
		}
		mod.Debug("sniffer stopped")
	}()

	// create service browser
	if mod.browser != nil {
		mod.browser.Stop(false)
	}
	mod.browser = NewBrowser()
	// start active browsing
	if ch, err := mod.browser.StartBrowsing(service, "local.", mod); err != nil {
		return err
	} else {
		// start listening for new services
		go func() {
			for entry := range ch {
				mod.onServiceDiscovered(entry)
			}
		}()
	}

	return nil
}

func (mod *ZeroGod) stopDiscovery() {
	if mod.browser != nil {
		mod.Debug("stopping discovery")
		mod.browser.Stop(true)
		mod.browser = nil
		mod.Debug("discovery stopped")
	}

	if mod.sniffer != nil {
		mod.Debug("stopping sniffer")
		mod.snifferCh <- nil
		mod.sniffer.Close()
		mod.sniffer = nil
		mod.snifferCh = nil
		mod.Debug("sniffer stopped")
	}
}
